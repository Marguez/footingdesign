# -*- coding: utf-8 -*-
"""footing_design_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YzoGMQesp3LW3NsJSAeRgSHILBCYgkWX
"""

# footing_app.py
import streamlit as st
import math
import pandas as pd

st.set_page_config(page_title="Footing Design Calculator", layout="wide")
st.title("Footing Design Calculator — Area, Shear & Reinforcement")

# ---------------------------
# Sidebar: Inputs
# ---------------------------
st.sidebar.header("Input parameters (SI units)")

B = st.sidebar.number_input("Footing width B (m)", min_value=0.1, value=1.50, step=0.5, format="%.3f")
L = st.sidebar.number_input("Footing length L (m)", min_value=0.1, value=1.50, step=0.5, format="%.3f")
t = st.sidebar.number_input("Footing thickness t (m)", min_value=0.05, value=0.50, step=0.1, format="%.3f")
d_f = st.sidebar.number_input("Foundation depth d_f (m)", min_value=0.0, value=0.00, step=0.1, format="%.3f")

cx = st.sidebar.number_input("Column width cx (m)", value=0.30, step=0.1, format="%.3f")
cy = st.sidebar.number_input("Column length cy (m)", value=0.30, step=0.1, format="%.3f")

gamma_s = st.sidebar.number_input("Unit weight of soil γ_s (kN/m³)", value=18.0, step=1.0, format="%.2f")
gamma_c = st.sidebar.number_input("Unit weight of concrete γ_c (kN/m³)", value=24.0, step=0.5, format="%.2f")
q_a = st.sidebar.number_input("Allowable soil pressure q_a (kPa)", value=200.0, step=10.0, format="%.2f")

fc_mp = st.sidebar.number_input("Concrete strength fc' (MPa)", min_value=10.0, value=25.0, step=1.0, format="%.2f")
fy_mp = st.sidebar.number_input("Yield strength of steel fy (MPa)", min_value=200.0, value=420.0, step=100.0, format="%.2f")

d_b_mm = st.sidebar.number_input("Main bar diameter d_b (mm)", min_value=6, value=16, step=1, format="%d")
cc_mm  = st.sidebar.number_input("Clear cover cc (mm)", min_value=5, value=50, step=1, format="%d")

P_D = st.sidebar.number_input("Dead axial load P_D (kN)", value=200.0, step=10.0, format="%.2f")
P_L = st.sidebar.number_input("Live axial load P_L (kN)", value=100.0, step=10.0, format="%.2f")
M_DX = st.sidebar.number_input("Dead moment about X M_DX (kN-m)", value=10, step=0.10, format="%.2f")
M_LX = st.sidebar.number_input("Live moment about X M_LX (kN-m)", value=10, step=0.10, format="%.2f")
M_DZ = st.sidebar.number_input("Dead moment about Z M_DZ (kN-m)", value=10, step=0.10, format="%.2f")
M_LZ = st.sidebar.number_input("Live moment about Z M_LZ (kN-m)", value=10, step=0.10, format="%.2f")

# quick derived conversions
cc_m = cc_mm / 1000.0
d_b_m = d_b_mm / 1000.0

# ---------------------------
# Calculations (same logic as your script)
# ---------------------------

# Service combos
P = P_D + P_L
M_X = M_DX + M_LX
M_Z = M_DZ + M_LZ

# effective bearing capacity
q_e = q_a - gamma_s * (d_f - t) - gamma_c * t
q_allow = q_e

# Determine CASE
if P != 0 and M_X != 0 and M_Z != 0:
    CASE = 3
    case_text = "Axial + moments in two directions (CASE = 3)"
elif P != 0 and (M_X != 0 or M_Z != 0):
    CASE = 2
    case_text = "Axial + moment in one direction (CASE = 2)"
elif P != 0 and M_X == 0 and M_Z == 0:
    CASE = 1
    case_text = "Axial only (CASE = 1)"
else:
    CASE = 0
    case_text = "No valid loading case (check inputs)"

# Present initial results
col1, col2 = st.columns([2, 1])
with col1:
    st.subheader("Determining footing dimension adequacy")
    st.write(case_text)
    st.write(f"P = {P:.2f} kN")
    st.write(f"M_X = {M_X:.2f} kN-m")
    st.write(f"M_Z = {M_Z:.2f} kN-m")
    st.write(f"Effective bearing capacity q_e = {q_e:.2f} kPa")

# dimension adequacy check
qmax = None
adequate_dims = None
if CASE == 1:
    qmax = P / (B * L)
elif CASE == 2:
    if M_X != 0:
        qmax = P / (B * L) + (6 * M_X) / (B * L**2)
    else:
        qmax = P / (B * L) + (6 * M_Z) / (L * B**2)
elif CASE == 3:
    qmax = P / (B * L) + (6 * M_X) / (B * L**2) + (6 * M_Z) / (L * B**2)

if qmax is not None:
    adequate_dims = qmax < q_e
    status = "ADEQUATE" if adequate_dims else "INADEQUATE"
    col2.metric("Soil pressure q_max (kPa)", f"{qmax:.2f}")
    if adequate_dims:
        st.success(f"Since q_max ({qmax:.2f} kPa) < q_e ({q_e:.2f} kPa), footing dimensions are adequate.")
    else:
        st.error(f"Since q_max ({qmax:.2f} kPa) ≥ q_e ({q_e:.2f} kPa), footing dimensions are INADEQUATE. Increase dimensions.")
        st.stop()

# ---------------------------
# Thickness (One-way shear) checks
# ---------------------------
st.subheader("Footing thickness adequacy — One-Way Shear (Beam Shear)")

P_U  = 1.2 * P_D  + 1.6 * P_L
M_UX = 1.2 * M_DX + 1.6 * M_LX
M_UZ = 1.2 * M_DZ + 1.6 * M_LZ

st.write(f"P_U = {P_U:.2f} kN, M_UX = {M_UX:.2f} kN-m, M_UZ = {M_UZ:.2f} kN-m")

# effective depth
d = (t * 1000.0 - cc_mm - d_b_mm / 2.0) / 1000.0  # m
if d <= 0:
    st.error(f"Effective depth d = {d:.4f} m is non-positive. Check t, cc_mm, d_b_mm.")
    st.stop()

# initialize placeholders
oneway_pass = True
WU1 = WU2 = WU3 = x = x_v = Vud = Vd = Vda = None

if CASE == 3:
    # check both directions
    # X-direction
    if M_UX >= M_UZ:
        MU = M_UX
        st.write(f"M_UX of {M_UX:.2f} kN-m governs in X-direction.")
        WU1 = P_U / B + 6 * MU / (B ** 2)
        WU2 = P_U / B - 6 * MU / (B ** 2)
        x = (B - cx) / 2.0
        x_v = x - d
        WU3 = WU1 - (WU1 - WU2) * (x_v) / B

        st.write(f"WU1 = {WU1:.2f} kN/m, WU2 = {WU2:.2f} kN/m")
        st.write(f"d = {d:.3f} m, x = {x:.3f} m, x_v = {x_v:.3f} m, WU3 = {WU3:.2f} kN/m")

        if x_v <= 0:
            st.warning("x_v <= 0 — shear control section is at/outside column face. One-way shear check not applicable (X).")
        else:
            Vud = 0.5 * (WU1 + WU3) * x_v   # kN
            Vd = Vud / (0.75 * L * d * 1000.0)  # MPa
            Vda = math.sqrt(fc_mp) / 6.0
            st.write(f"Vud = {Vud:.2f} kN, Vd = {Vd:.2f} MPa, Allowable Vd = {Vda:.2f} MPa")
            if Vda > Vd:
                st.success("One-way shear (X): SAFE.")
            else:
                st.error("One-way shear (X): NOT SAFE.")
                oneway_pass = False

    # Z-direction
    if M_UZ > M_UX:
        MU = M_UZ
        st.write(f"M_UZ of {M_UZ:.2f} kN-m governs in Z-direction.")
        WU1 = P_U / L + 6 * MU / (L ** 2)
        WU2 = P_U / L - 6 * MU / (L ** 2)
        x = (L - cy) / 2.0
        x_v = x - d
        WU3 = WU1 - (WU1 - WU2) * (x_v) / L

        st.write(f"WU1 = {WU1:.2f} kN/m, WU2 = {WU2:.2f} kN/m")
        st.write(f"d = {d:.3f} m, x = {x:.3f} m, x_v = {x_v:.3f} m, WU3 = {WU3:.2f} kN/m")

        if x_v <= 0:
            st.warning("x_v <= 0 — shear control section is at/outside column face. One-way shear check not applicable (Z).")
        else:
            Vud = 0.5 * (WU1 + WU3) * x_v   # kN
            Vd = Vud / (0.75 * B * d * 1000.0)  # MPa
            Vda = math.sqrt(fc_mp) / 6.0
            st.write(f"Vud = {Vud:.2f} kN, Vd = {Vd:.2f} MPa, Allowable Vd = {Vda:.2f} MPa")
            if Vda > Vd:
                st.success("One-way shear (Z): SAFE.")
            else:
                st.error("One-way shear (Z): NOT SAFE.")
                oneway_pass = False

elif CASE == 2:
    MU = M_UX
    st.write(f"M_UX of {M_UX:.2f} kN-m governs (CASE = 2).")
    WU1 = P_U / B + 6 * MU / (B ** 2)
    WU2 = P_U / B - 6 * MU / (B ** 2)
    x = (B - cx) / 2.0
    x_v = x - d
    WU3 = WU1 - (WU1 - WU2) * (x_v) / B

    st.write(f"WU1 = {WU1:.2f} kN/m, WU2 = {WU2:.2f} kN/m")
    st.write(f"d = {d:.3f} m, x = {x:.3f} m, x_v = {x_v:.3f} m, WU3 = {WU3:.2f} kN/m")

    if x_v <= 0:
        st.warning("x_v <= 0 — shear control section is at/outside column face. One-way shear check not applicable.")
    else:
        Vud = 0.5 * (WU1 + WU3) * x_v   # kN
        Vd = Vud / (0.75 * L * d * 1000.0)  # MPa
        Vda = math.sqrt(fc_mp) / 6.0
        st.write(f"Vud = {Vud:.2f} kN, Vd = {Vd:.2f} MPa, Allowable Vd = {Vda:.2f} MPa")
        if Vda > Vd:
            st.success("One-way shear: SAFE.")
        else:
            st.error("One-way shear: NOT SAFE.")
            oneway_pass = False

elif CASE == 1:
    if B > L:
        x = (B - cx) / 2.0
        x_v = x - d
        WU = P_U / B
        st.write(f"d = {d:.3f} m, x = {x:.3f} m, x_v = {x_v:.3f} m, WU = {WU:.2f} kN/m")
        if x_v <= 0:
            st.warning("x_v <= 0 — shear control section is at/outside column face. One-way shear check not applicable.")
        else:
            Vud = WU * x_v
            Vd = Vud / (0.75 * L * d * 1000.0)
            Vda = math.sqrt(fc_mp) / 6.0
            st.write(f"Vud = {Vud:.2f} kN, Vd = {Vd:.2f} MPa, Allowable Vd = {Vda:.2f} MPa")
            if Vda > Vd:
                st.success("One-way shear: SAFE.")
            else:
                st.error("One-way shear: NOT SAFE.")
                oneway_pass = False
    else:
        x = (L - cy) / 2.0
        x_v = x - d
        WU = P_U / L
        st.write(f"d = {d:.3f} m, x = {x:.3f} m, x_v = {x_v:.3f} m, WU = {WU:.2f} kN/m")
        if x_v <= 0:
            st.warning("x_v <= 0 — shear control section is at/outside column face. One-way shear check not applicable.")
        else:
            Vud = WU * x_v
            Vd = Vud / (0.75 * B * d * 1000.0)
            Vda = math.sqrt(fc_mp) / 6.0
            st.write(f"Vud = {Vud:.2f} kN, Vd = {Vd:.2f} MPa, Allowable Vd = {Vda:.2f} MPa")
            if Vda > Vd:
                st.success("One-way shear: SAFE.")
            else:
                st.error("One-way shear: NOT SAFE.")
                oneway_pass = False

# ---------------------------
# Two-way shear (Punching)
# ---------------------------
st.subheader("Two-Way Shear / Punching Shear Check")

twopass = True
if CASE == 3:
    q1 = P_U / (B * L) + (6 * M_UX) / (B * (L ** 2)) + (6 * M_UZ) / ((B ** 2) * L)
    q2 = P_U / (B * L) - (6 * M_UX) / (B * (L ** 2)) + (6 * M_UZ) / ((B ** 2) * L)
    q3 = P_U / (B * L) + (6 * M_UX) / (B * (L ** 2)) - (6 * M_UZ) / ((B ** 2) * L)
    q4 = P_U / (B * L) - (6 * M_UX) / (B * (L ** 2)) - (6 * M_UZ) / ((B ** 2) * L)
    qave = (q1 + q2 + q3 + q4) / 4.0

    st.write(f"q1 = {q1:.2f} kPa, q2 = {q2:.2f} kPa, q3 = {q3:.2f} kPa, q4 = {q4:.2f} kPa")
    st.write(f"qave = {qave:.2f} kPa")

    Cxd = cx + d
    Cyd = cy + d
    Bo = 2 * (Cxd + Cyd)
    Vup = P_U - qave * Cxd * Cyd
    Vp = Vup * 1000 / (0.75 * Bo * d * 1_000_000)
    Vpa = math.sqrt(fc_mp) / 3.0

    st.write(f"Cxd = {Cxd:.2f} m, Cyd = {Cyd:.2f} m, Bo = {Bo:.2f} m")
    st.write(f"Vup = {Vup:.2f} kN, Vp = {Vp:.2f} MPa, Allowable Vp = {Vpa:.2f} MPa")
    if Vpa > Vp:
        st.success("Two-way/punching shear: SAFE.")
    else:
        st.error("Two-way/punching shear: NOT SAFE.")
        twopass = False

elif CASE == 2:
    q1 = P_U / (B * L) + (6 * M_UX) / (B * (L ** 2))
    q2 = P_U / (B * L) - (6 * M_UX) / (B * (L ** 2))
    qave = (q1 + q2) / 2.0

    st.write(f"q1 = {q1:.2f} kPa, q2 = {q2:.2f} kPa, qave = {qave:.2f} kPa")
    Cxd = cx + d
    Cyd = cy + d
    Bo = 2 * (Cxd + Cyd)
    Vup = P_U - qave * Cxd * Cyd
    Vp = Vup * 1000 / (0.75 * Bo * d * 1e6)
    Vpa = math.sqrt(fc_mp) / 3.0
    st.write(f"Cxd = {Cxd:.2f} m, Cyd = {Cyd:.2f} m, Bo = {Bo:.2f} m")
    st.write(f"Vup = {Vup:.2f} kN, Vp = {Vp:.2f} MPa, Allowable Vp = {Vpa:.2f} MPa")
    if Vpa > Vp:
        st.success("Two-way/punching shear: SAFE.")
    else:
        st.error("Two-way/punching shear: NOT SAFE.")
        twopass = False

elif CASE == 1:
    q = P_U / (B * L)
    st.write(f"q = {q:.2f} kPa")
    Cxd = cx + d
    Cyd = cy + d
    Bo = 2 * (Cxd + Cyd)
    Vup = P_U - q * Cxd * Cyd
    Vp = Vup * 1000 / (0.75 * Bo * d * 1e6)
    Vpa = math.sqrt(fc_mp) / 3.0
    st.write(f"Cxd = {Cxd:.2f} m, Cyd = {Cyd:.2f} m, Bo = {Bo:.2f} m")
    st.write(f"Vup = {Vup:.2f} kN, Vp = {Vp:.2f} MPa, Allowable Vp = {Vpa:.2f} MPa")
    if Vpa > Vp:
        st.success("Two-way/punching shear: SAFE.")
    else:
        st.error("Two-way/punching shear: NOT SAFE.")
        twopass = False

# ---------------------------
# Reinforcement design
# ---------------------------
st.subheader("Reinforcement (Flexural) Design")

# For many parts we need WU1, WU2, x; ensure they're computed (they will be from previous sections)
# If not present, compute simple defaults for CASE=1
try:
    _ = WU1
except NameError:
    WU1 = P_U / B
    WU2 = WU1
    x = (B - cx) / 2.0

# proceed casewise
if CASE == 3:
    if M_UX > M_UZ:
        st.write(f"M_UX of {M_UX:.2f} kN-m governs.")
        # WU1 and WU2 from earlier in X-direction should be available; if not compute:
        WU1 = P_U / B + 6 * M_UX / (B ** 2)
        WU2 = P_U / B - 6 * M_UX / (B ** 2)
        WU4 = WU1 - (WU1 - WU2) * (x / B)
        MUD = 0.5 * WU1 * x * (2/3 * x) + 0.5 * WU4 * x * (x / 3)

        if fc_mp <= 28:
            beta = 0.85
        elif fc_mp < 55:
            beta = 0.85 - 0.05/7 * (fc_mp - 28)
        else:
            beta = 0.65

        MUT = 0.9 * (51/160) * fc_mp * L * 1000 * beta * d**2 * (1 - 3*beta/16)

        st.write(f"WU4 = {WU4:.2f} kN/m")
        st.write(f"MUD = {MUD:.2f} kN-m")
        st.write(f"MUT = {MUT:.2f} kN-m")

        if MUT > MUD:
            st.success("Since MUT > MUD, tension-controlled (phi = 0.9)")
            phi = 0.9
        else:
            st.warning("Since MUT <= MUD, transition region (phi = assumed 0.75)")
            phi = 0.75

        Rn = round(MUD * 1e6 / (phi * L * d**2 * 1e9), 3)
        # protect negative / domain error in sqrt
        tmp = 1 - 2*Rn/(0.85*fc_mp)
        rho_actual = 0.0
        if tmp >= 0:
            rho_actual = round(0.85 * fc_mp / fy_mp * (1 - math.sqrt(tmp)), 5)
        else:
            rho_actual = 0.0
        rho_min = round(max(1.4/fy_mp, 0.25 * math.sqrt(fc_mp) / fy_mp), 5)
        rho_des = max(rho_actual, rho_min)

        st.write(f"Rn = {Rn:.3f}")
        st.write(f"rho_actual = {rho_actual:.5f}")
        st.write(f"rho_min = {rho_min:.5f}")
        st.write(f"rho_des (governs) = {rho_des:.5f}")

        As = rho_des * L * d * 1e6  # mm2
        n = math.ceil(As * 4 / (math.pi * d_b_mm**2))

        st.write(f"As = {As:.2f} mm²")
        st.warning(f"Provide {n}–{d_b_mm} mm diameter DRB both ways.")

    elif M_UZ > M_UX:
        st.write(f"M_UZ of {M_UZ:.2f} kN-m governs.")
        WU1 = P_U / L + 6 * M_UZ / (L ** 2)
        WU2 = P_U / L - 6 * M_UZ / (L ** 2)
        WU4 = WU1 - (WU1 - WU2) * (x / L)
        MUD = 0.5 * WU1 * x * (2/3 * x) + 0.5 * WU4 * x * (x / 3)

        if fc_mp <= 28:
            beta = 0.85
        elif fc_mp < 55:
            beta = 0.85 - 0.05/7 * (fc_mp - 28)
        else:
            beta = 0.65

        MUT = 0.9 * (51/160) * fc_mp * B * 1000 * beta * d**2 * (1 - 3*beta/16)

        st.write(f"WU4 = {WU4:.2f} kN/m")
        st.write(f"MUD = {MUD:.2f} kN-m")
        st.write(f"MUT = {MUT:.2f} kN-m")

        if MUT > MUD:
            st.success("Since MUT > MUD, tension-controlled (phi = 0.9)")
            phi = 0.9
        else:
            st.warning("Since MUT <= MUD, transition region (phi = assumed 0.75)")
            phi = 0.75

        Rn = round(MUD * 1e6 / (phi * B * d**2 * 1e9), 3)
        tmp = 1 - 2*Rn/(0.85*fc_mp)
        rho_actual = 0.0
        if tmp >= 0:
            rho_actual = round(0.85 * fc_mp / fy_mp * (1 - math.sqrt(tmp)), 5)
        else:
            rho_actual = 0.0
        rho_min = round(max(1.4/fy_mp, 0.25 * math.sqrt(fc_mp) / fy_mp), 5)
        rho_des = max(rho_actual, rho_min)

        st.write(f"Rn = {Rn:.3f}")
        st.write(f"rho_actual = {rho_actual:.5f}")
        st.write(f"rho_min = {rho_min:.5f}")
        st.write(f"rho_des (governs) = {rho_des:.5f}")

        As = rho_des * L * d * 1e6  # mm2
        n = math.ceil(As * 4 / (math.pi * d_b_mm**2))
        st.write(f"As = {As:.2f} mm²")
        st.warning(f"Provide {n}–{d_b_mm} mm diameter DRB both ways.")

elif CASE == 2:
    st.write(f"CASE = 2: M_UX governs (M_UX = {M_UX:.2f} kN-m).")
    WU1 = P_U / B + 6 * M_UX / (B ** 2)
    WU2 = P_U / B - 6 * M_UX / (B ** 2)
    WU4 = WU1 - (WU1 - WU2) * (x / B)
    MUD = 0.5 * WU1 * x * (2/3 * x) + 0.5 * WU4 * x * (x / 3)

    if fc_mp <= 28:
        beta = 0.85
    elif fc_mp < 55:
        beta = 0.85 - 0.05/7 * (fc_mp - 28)
    else:
        beta = 0.65

    MUT = 0.9 * (51/160) * fc_mp * L * 1000 * beta * d**2 * (1 - 3*beta/16)

    st.write(f"WU4 = {WU4:.2f} kN/m")
    st.write(f"MUD = {MUD:.2f} kN-m")
    st.write(f"MUT = {MUT:.2f} kN-m")

    if MUT > MUD:
        st.success("Since MUT > MUD, tension-controlled (phi = 0.9)")
        phi = 0.9
    else:
        st.warning("Since MUT <= MUD, transition region (phi = assumed 0.75)")
        phi = 0.75

    Rn = round(MUD * 1e6 / (phi * L * d**2 * 1e9), 3)
    tmp = 1 - 2*Rn/(0.85*fc_mp)
    rho_actual = 0.0
    if tmp >= 0:
        rho_actual = round(0.85 * fc_mp / fy_mp * (1 - math.sqrt(tmp)), 5)
    else:
        rho_actual = 0.0
    rho_min = round(max(1.4/fy_mp, 0.25 * math.sqrt(fc_mp) / fy_mp), 5)
    rho_des = max(rho_actual, rho_min)

    st.write(f"Rn = {Rn:.3f}")
    st.write(f"rho_actual = {rho_actual:.5f}")
    st.write(f"rho_min = {rho_min:.5f}")
    st.write(f"rho_des (governs) = {rho_des:.5f}")

    As = rho_des * L * d * 1e6  # mm2
    n = math.ceil(As * 4 / (math.pi * d_b_mm**2))
    st.write(f"As = {As:.2f} mm²")
    st.warning(f"Provide {n}–{d_b_mm} mm diameter DRB both ways.")

elif CASE == 1:
    if B > L:
        st.write("CASE = 1, B > L: flexural check across B.")
        MUD = 0.5 * WU * x**2
        if fc_mp <= 28:
            beta = 0.85
        elif fc_mp < 55:
            beta = 0.85 - 0.05/7 * (fc_mp - 28)
        else:
            beta = 0.65

        MUT = 0.9 * (51/160) * fc_mp * L * 1000 * beta * d**2 * (1 - 3*beta/16)
        st.write(f"MUD = {MUD:.2f} kN-m, MUT = {MUT:.2f} kN-m")
        if MUT > MUD:
            st.success("Since MUT > MUD, tension-controlled (phi = 0.9)")
            phi = 0.9
        else:
            st.warning("Since MUT <= MUD, transition region (phi = assumed 0.75)")
            phi = 0.75

        Rn = round(MUD * 1e6 / (phi * L * d**2 * 1e9), 3)
        tmp = 1 - 2*Rn/(0.85*fc_mp)
        rho_actual = 0.0
        if tmp >= 0:
            rho_actual = round(0.85 * fc_mp / fy_mp * (1 - math.sqrt(tmp)), 5)
        else:
            rho_actual = 0.0
        rho_min = round(max(1.4/fy_mp, 0.25 * math.sqrt(fc_mp) / fy_mp), 5)
        rho_des = max(rho_actual, rho_min)

        st.write(f"Rn = {Rn:.3f}")
        st.write(f"rho_actual = {rho_actual:.5f}")
        st.write(f"rho_min = {rho_min:.5f}")
        st.write(f"rho_des (governs) = {rho_des:.5f}")

        As = rho_des * L * d * 1e6  # mm2
        n = math.ceil(As * 4 / (math.pi * d_b_mm**2))
        st.write(f"As = {As:.2f} mm²")
        st.warning(f"Provide {n}–{d_b_mm} mm diameter DRB both ways.")
    else:
        st.write("CASE = 1, L >= B: flexural check across L.")
        MUD = 0.5 * WU * x**2
        if fc_mp <= 28:
            beta = 0.85
        elif fc_mp < 55:
            beta = 0.85 - 0.05/7 * (fc_mp - 28)
        else:
            beta = 0.65

        MUT = 0.9 * (51/160) * fc_mp * B * 1000 * beta * d**2 * (1 - 3*beta/16)
        st.write(f"MUD = {MUD:.2f} kN-m, MUT = {MUT:.2f} kN-m")
        if MUT > MUD:
            st.success("Since MUT > MUD, tension-controlled (phi = 0.9)")
            phi = 0.9
        else:
            st.warning("Since MUT <= MUD, transition region (phi = assumed 0.75)")
            phi = 0.75

        Rn = round(MUD * 1e6 / (phi * B * d**2 * 1e9), 3)
        tmp = 1 - 2*Rn/(0.85*fc_mp)
        rho_actual = 0.0
        if tmp >= 0:
            rho_actual = round(0.85 * fc_mp / fy_mp * (1 - math.sqrt(tmp)), 5)
        else:
            rho_actual = 0.0
        rho_min = round(max(1.4/fy_mp, 0.25 * math.sqrt(fc_mp) / fy_mp), 5)
        rho_des = max(rho_actual, rho_min)

        st.write(f"Rn = {Rn:.3f}")
        st.write(f"rho_actual = {rho_actual:.5f}")
        st.write(f"rho_min = {rho_min:.5f}")
        st.write(f"rho_des (governs) = {rho_des:.5f}")

        As = rho_des * B * d * 1e6  # mm2
        n = math.ceil(As * 4 / (math.pi * d_b_mm**2))
        st.write(f"As = {As:.2f} mm²")
        st.warning(f"Provide {n}–{d_b_mm} mm diameter DRB both ways.")

st.markdown("## 🔎 Design Summary Highlights")
def result_box(label, value, allowable, unit, safe_if="less"):
    if safe_if == "less":  # stress checks (value < allowable is safe)
        if value <= allowable:
            color = "green"
            status = "SAFE"
        else:
            color = "red"
            status = "FAILED"
    else:  # capacity checks (value > allowable is safe)
        if value >= allowable:
            color = "green"
            status = "SAFE"
        else:
            color = "red"
            status = "FAILED"

    return f"""
    <div style="background-color:{color}; padding:10px; border-radius:8px; margin-bottom:5px;">
        <b>{label}</b><br>
        Value = {value:.2f} {unit} | Allowable = {allowable:.2f} {unit} <br>
        <b>Status: {status}</b>
    </div>
    """

summary_html = ""
summary_html += result_box("Maximum Soil Pressure", qmax, q_allow, "kPa", safe_if="less")
summary_html += result_box("One-Way Shear (Vd)", Vd, Vda, "MPa", safe_if="less")
summary_html += result_box("Punching Shear (Vp)", Vp, Vpa, "MPa", safe_if="less")

summary_html += (
    f"<div style='background-color:green; padding:10px; border-radius:8px; margin-top:10px;'>"
    f"<b>Reinforcement Requirement</b><br>"
    f"Provide {n} bars of {d_b_mm} mm DRB both ways."
    f"</div>"
)


st.markdown(summary_html, unsafe_allow_html=True)


# ---------------------------
# Downloadable summary
# ---------------------------
st.markdown("---")
st.subheader("Download results")

results = {
    "B_m": B, "L_m": L, "t_m": t, "d_m": d, "cx_m": cx, "cy_m": cy,
    "P_kN": P, "M_X_kN_m": M_X, "M_Z_kN_m": M_Z,
    "q_e_kPa": q_e, "q_max_kPa": qmax,
    "P_U_kN": P_U, "M_UX_kN_m": M_UX, "M_UZ_kN_m": M_UZ,
    "Vd_MPa": Vd if 'Vd' in locals() else None,
    "Vda_MPa": Vda if 'Vda' in locals() else None,
    "Vp_MPa": Vp if 'Vp' in locals() else None,
    "Vpa_MPa": Vpa if 'Vpa' in locals() else None,
    "As_mm2": As if 'As' in locals() else None,
    "n_bars": n if 'n' in locals() else None,
    "d_b_mm": d_b_mm
}
df = pd.DataFrame([results])
csv = df.to_csv(index=False).encode('utf-8')
st.download_button(label="Download results CSV", data=csv, file_name="footing_results.csv", mime="text/csv")

st.write("Done — change any input on the left to see the outputs update in real time.")
